# Project testting document

## Unit Test Coverage Report

Unit test coverage report is generated with coverage.py and is visible [here](https://viljamilatvala.github.io/2048-algorithms/documentation/coverage_report/index.html)

## Unit Testing Implementation

Unit tests are created with the standard library's unittest framework. Currently tests exist for the GameHandler -class and the MiniMaxPlayer -class. Not included in unit testing are User Interface in /src/app.py, browser controls in BrowserGame -class and UserInputPlayer -class which itself is used in manually testing BrowserGame and the UI.

Unit tests can be run from the project root by calling

```
>coverage run -m unittest discover
```

After running the test, a HTML report can be generated by caclling

```
>coverage html
```

## Manual Testing

UserInputPlayer -class was created to prompt and relay move commands from the user. This way we can verify that the game loop and browser controls work as expected.

This test can be replicated by running /src/app.py, selecting UserInputPlayer as the player, and entering the wished amount of games to play. After that the user will be prompted for next moves, and they can inspect if the game obeys those instructions, loops and opens/closes new games correctly.

## Performance Testing

Testing was done by playing 17 games with the algorithm, having the iterative deepening kick in after 800 moves and progressing to the next search depth if accumulated time is below 0.3 seconds

### Algorithm Speed

The speed of the algorithm is influenced by the depth of the gametrees search. When looking at the average times to calculate the move to play for different depths, we can see that the time consumed does not increase exponentially as one could assume from Minimax's time complexity O(m^d) where m is the branching factor and d is the search depth. From depth 3 to 4 this seems to be true but going deeper than that the search times seem to get lower. This is due to the time restriction which ensures that if calculating best move to depth n exceeds 0.3s, the next depth n+1 won't be calculated. After the first 800 moves where the iterativeness is skipped, majority of moves are calculated to depth 4 but only gametrees where Alpha-Beta pruning reduces the size of generated states drastically ever reach depth 5 and up. If the time restriction would be exceeded the exponential growth in time used would be more visible in higher depths also.

![img](/documentation/graphs/depthtime.png)
![img](/documentation/graphs/depthtime2.png)

### Game Performance

The algorithm managed to get the highest tile value of 2048 13 times, and a value of 1024 4 times.

On average, the algorithm survived to play 1658 rounds of the game. One game survived significantly longer than the average, for 5484 rounds.

![img](/documentation/graphs/rounds.png)
![img](/documentation/graphs/score.png)
